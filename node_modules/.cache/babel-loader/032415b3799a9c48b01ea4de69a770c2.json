{"ast":null,"code":"export default class MachineNode {\n  constructor(_name, _input1, _input2, _input3, _input4, _output) {\n    this.name = _name;\n    this.children = [];\n    this.input1 = _input1; // {name:, amount:, max: }\n\n    this.input2 = _input2;\n    this.input3 = _input3;\n    this.input4 = _input4;\n    this.output = _output;\n    this.currentOutput = [];\n    this.before = 0; // this.width;\n    // this.height;\n    // this.cost = [];\n  }\n\n  getOutput() {\n    return this.output;\n  }\n\n  getCurrentOutput() {\n    return this.currentOutput;\n  }\n\n  addCurrentOutput(child, material, amount) {\n    //if output to child already exists, only update amount\n    //if output to child does not exist, add new output object\n    let search = this.findOutputToChild(child);\n\n    if (search !== -1) {\n      search.amount = amount;\n    } else {\n      let out = {\n        child: child,\n        material: material,\n        amount: amount\n      };\n      this.getCurrentOutput().push(out);\n    }\n  }\n\n  findOutputToChild(child) {\n    for (let output of this.getCurrentOutput()) {\n      if (output.child === child) {\n        return output;\n      }\n    }\n\n    return -1;\n  }\n\n  getChildren() {\n    return this.children;\n  }\n\n  getInput1() {\n    return this.input1;\n  }\n\n  getInput2() {\n    return this.input2;\n  }\n\n  getInput3() {\n    return this.input3;\n  }\n\n  getInput4() {\n    return this.input4;\n  }\n\n  getInput() {\n    return [this.getInput1(), this.getInput2(), this.getInput3(), this.getInput4()];\n  }\n\n  getAvailableInput(material) {\n    return this.getInputMax(material) - this.getInputAmount(material);\n  }\n\n  addInput(material, amount) {\n    console.log(this.getInput());\n\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        input.amount = input.amount + amount; //Math.min(input.amount + _amount, this.getInputMax(material))\n\n        return input.amount;\n      }\n    }\n  }\n\n  setInput(material, amount) {\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        input.amount = amount;\n        return input;\n      }\n    }\n\n    return -1;\n  }\n\n  removeInput(material, amount) {\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        input.amount -= amount;\n        return input.amount;\n      }\n    }\n  }\n\n  addOutput(_name, _amount) {\n    this.output = {\n      name: _name,\n      amount: _amount\n    };\n  }\n\n  getInputAmount(material) {\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        return input.amount;\n      }\n    }\n\n    return 0;\n  }\n\n  checkInput(material) {\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getInputMax(material) {\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        return input.max;\n      }\n    }\n\n    return 0;\n  } // edit this so that it correctly splits the output \n  // and records how much of what is sent to which child\n\n\n  sendOutput() {\n    let material = this.getOutput().name;\n    let amount = this.getOutput().amount;\n    let allChildren = this.getChildren();\n    let children = []; //only include children that accept the output\n\n    for (let child of allChildren) {\n      if (child.checkInput(material)) {\n        children.push(child);\n      }\n    }\n\n    let numChildren = children.length;\n    let split = this.getOutput().amount / numChildren; //saves what the input was prior to any changes for later\n\n    for (let child of children) {\n      child.before = child.getInputAmount(material);\n    } //removes all previous input from the parent node\n\n\n    for (let i = 0; i < children.length - 1; i++) {\n      children[i].removeInput(material, this.findOutputToChild(children[i]).amount); //children[i].removeInput(material, amount / (children.length - 1))\n    } //if too much output, just set all to max\n\n\n    let availableInput = 0;\n\n    for (let child of children) {\n      availableInput += child.getAvailableInput(material);\n    }\n\n    if (availableInput < amount) {\n      for (let child of children) {\n        child.setInput(material, child.getInputMax(material));\n      }\n\n      return;\n    }\n\n    for (let child of children) {\n      child.addInput(material, split);\n    }\n\n    MachineNode.evenOutputSplit(children, material);\n\n    for (let child of children) {\n      let amountSent = child.getInputAmount(material) - child.before;\n      this.addCurrentOutput(child, material, amountSent);\n    }\n  }\n\n  static evenOutputSplit(children, material) {\n    if (children.length <= 1) {\n      return;\n    }\n\n    let i = 0;\n    let countGood = 0; // let childrenToUpdate = [];\n\n    while (true) {\n      //make all children even split and not above max\n      let diff = children[i].getAvailableInput(material);\n      let nextChild = i + 1 >= children.length ? 0 : i + 1;\n\n      if (diff <= 0) {\n        children[i].setInput(material, children[i].getInputAmount(material) - 1);\n        children[nextChild].setInput(material, children[nextChild].getInputAmount(material) + 1);\n        countGood = 0;\n      } else {\n        countGood++;\n      }\n\n      i = nextChild;\n\n      if (countGood === children.length) {\n        break;\n      }\n    } // let total = 0;\n    // for (let child of childrenToUpdate) {\n    //     total += child.getInputAmount(material)\n    // }\n    // for (let child of childrenToUpdate) {\n    //     child.setInput(material, total / childrenToUpdate.length())\n    // }\n\n  }\n\n  wipeOutputToChildren(output, children) {\n    if (children.length <= 1) {\n      return;\n    }\n\n    console.log('wiped');\n    let split = Math.round(output.amount / Math.max(children.length, 1));\n\n    for (let child of children) {\n      child.removeInput(output.name, split);\n    }\n  }\n\n  splitOutput(output, children) {\n    let material = output.name;\n    let amount = output.amount;\n    this.wipeOutputToChildren(output, children);\n    let countAtMax = 0; //if at full capacity don't count in the split\n\n    for (let child of children) {\n      if (child.getInputAmount(material) === child.getInputMax(material)) {\n        countAtMax += 1;\n      }\n    }\n\n    let split = Math.round(amount / (children.length - countAtMax));\n\n    for (let child of children) {\n      child.addInput(material, split);\n      amount -= split;\n    }\n\n    if (amount > 0) {\n      this.splitOutput(material, amount, children);\n    }\n  }\n\n  addChild(_child) {\n    //sets a child node and adds parent\n    this.children.push(_child);\n  }\n\n  removeChild(_child) {\n    for (let child of this.getChildren()) {\n      if (_child === child) {\n        this.children = this.getChildren().filter(c => {\n          return c !== _child;\n        });\n      }\n    }\n  }\n\n  wipeInput() {\n    this.input = [];\n  }\n\n  wipeInputOutput() {\n    this.input = []; //[{name: a, amount:x}, ...]\n\n    this.output = {};\n  }\n\n  wipeChildrenInput() {\n    for (let child of this.children) {\n      child.wipeInput();\n    }\n  }\n\n  wipeChildren() {\n    this.children = [];\n  }\n\n  wipeAll() {\n    this.children = [];\n    this.maxInput = [];\n    this.input = []; //[{name: a, amount:x}, ...]\n\n    this.output = {};\n  }\n\n}","map":{"version":3,"sources":["C:/Users/cshan/Box Sync/website/satisfactory2/src/backend/machineNode.js"],"names":["MachineNode","constructor","_name","_input1","_input2","_input3","_input4","_output","name","children","input1","input2","input3","input4","output","currentOutput","before","getOutput","getCurrentOutput","addCurrentOutput","child","material","amount","search","findOutputToChild","out","push","getChildren","getInput1","getInput2","getInput3","getInput4","getInput","getAvailableInput","getInputMax","getInputAmount","addInput","console","log","input","setInput","removeInput","addOutput","_amount","checkInput","max","sendOutput","allChildren","numChildren","length","split","i","availableInput","evenOutputSplit","amountSent","countGood","diff","nextChild","wipeOutputToChildren","Math","round","splitOutput","countAtMax","addChild","_child","removeChild","filter","c","wipeInput","wipeInputOutput","wipeChildrenInput","wipeChildren","wipeAll","maxInput"],"mappings":"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","sourcesContent":["export default class MachineNode {\r\n    constructor(_name, _input1, _input2, _input3, _input4, _output) {\r\n        this.name = _name;\r\n        this.children = [];\r\n        this.input1 = _input1; // {name:, amount:, max: }\r\n        this.input2 = _input2;\r\n        this.input3 = _input3;\r\n        this.input4 = _input4;\r\n        this.output = _output;\r\n        this.currentOutput = [];\r\n        this.before = 0;\r\n        // this.width;\r\n        // this.height;\r\n        // this.cost = [];\r\n    }\r\n\r\n    getOutput() {\r\n        return (this.output)\r\n    }\r\n\r\n    getCurrentOutput() {\r\n        return (this.currentOutput)\r\n    }\r\n\r\n    addCurrentOutput(child, material, amount) {\r\n        //if output to child already exists, only update amount\r\n        //if output to child does not exist, add new output object\r\n        let search = this.findOutputToChild(child)\r\n        if ( search !== -1) { \r\n            search.amount = amount \r\n        } else {\r\n            let out = {child: child, material: material, amount: amount}\r\n            this.getCurrentOutput().push(out)\r\n        }\r\n        \r\n    }\r\n\r\n    findOutputToChild(child) {\r\n        for(let output of this.getCurrentOutput()) {\r\n            if(output.child === child) { return output }\r\n        }\r\n        return(-1)\r\n    }\r\n\r\n    getChildren() {\r\n        return (this.children)\r\n    }\r\n\r\n    getInput1() {\r\n        return (this.input1)\r\n    }\r\n\r\n    getInput2() {\r\n        return (this.input2)\r\n    }\r\n\r\n    getInput3() {\r\n        return (this.input3)\r\n    }\r\n\r\n    getInput4() {\r\n        return (this.input4)\r\n    }\r\n\r\n    getInput() {\r\n        return([\r\n            this.getInput1(), this.getInput2(), this.getInput3(), this.getInput4()\r\n        ])\r\n    }\r\n\r\n    getAvailableInput(material) {\r\n        return(this.getInputMax(material) - this.getInputAmount(material))\r\n    }\r\n\r\n    addInput(material, amount) {\r\n        console.log(this.getInput())\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) {\r\n                input.amount = input.amount + amount//Math.min(input.amount + _amount, this.getInputMax(material))\r\n                return(input.amount)\r\n            }\r\n        }\r\n    }\r\n\r\n    setInput(material, amount) {\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) {\r\n                input.amount = amount;\r\n                return (input)\r\n            }\r\n        }\r\n        return (-1)\r\n    }\r\n\r\n    removeInput(material, amount) {\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) {\r\n                input.amount -= amount\r\n                return(input.amount)\r\n            }\r\n        }\r\n    }\r\n\r\n    addOutput(_name, _amount) {\r\n        this.output = {\r\n            name: _name,\r\n            amount: _amount\r\n        }\r\n    }\r\n\r\n    getInputAmount(material) {\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) { return (input.amount) }\r\n        }\r\n        return(0)\r\n    }\r\n\r\n    checkInput(material) {\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) { return (true) }\r\n        }\r\n        return (false)\r\n    }\r\n\r\n    getInputMax(material) {\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) { return(input.max) } \r\n        }\r\n        return(0)\r\n    }\r\n\r\n\r\n    // edit this so that it correctly splits the output \r\n    // and records how much of what is sent to which child\r\n\r\n    sendOutput() {\r\n        let material = this.getOutput().name;\r\n        let amount = this.getOutput().amount;\r\n        let allChildren = this.getChildren();\r\n        let children = [];\r\n\r\n        //only include children that accept the output\r\n        for(let child of allChildren) {\r\n            if( child.checkInput(material) ) { children.push(child) }\r\n        }\r\n\r\n        let numChildren = children.length\r\n        let split = this.getOutput().amount / numChildren\r\n\r\n        //saves what the input was prior to any changes for later\r\n        for(let child of children) {\r\n            child.before = child.getInputAmount(material)\r\n        }\r\n\r\n        //removes all previous input from the parent node\r\n        for(let i=0; i < (children.length - 1); i++) {\r\n            children[i].removeInput(material, this.findOutputToChild(children[i]).amount )\r\n            //children[i].removeInput(material, amount / (children.length - 1))\r\n        }\r\n        \r\n\r\n        //if too much output, just set all to max\r\n        let availableInput = 0;\r\n        for (let child of children) {\r\n            availableInput += child.getAvailableInput(material)\r\n        }\r\n        if(availableInput < amount) {\r\n            for(let child of children) {\r\n                child.setInput(material, child.getInputMax(material))\r\n            }\r\n            return\r\n        }\r\n        \r\n        for (let child of children) {\r\n            child.addInput(material, split)\r\n        }\r\n\r\n        MachineNode.evenOutputSplit(children, material)\r\n\r\n        for(let child of children) {\r\n            let amountSent = child.getInputAmount(material) - child.before\r\n            this.addCurrentOutput(child, material, amountSent)\r\n        }\r\n    }\r\n\r\n    static evenOutputSplit(children, material) {\r\n        if(children.length <= 1){return}\r\n\r\n        let i = 0;\r\n        let countGood = 0;\r\n        // let childrenToUpdate = [];\r\n\r\n        while(true) { //make all children even split and not above max\r\n            let diff = children[i].getAvailableInput(material)\r\n            let nextChild = ( i+1 >= children.length ) ? 0 : i+1\r\n\r\n            if(diff <= 0) {\r\n                children[i].setInput( material, children[i].getInputAmount(material) - 1 )\r\n                children[nextChild].setInput (material, children[nextChild].getInputAmount(material) + 1 )\r\n                countGood = 0;\r\n            } else {\r\n                countGood++\r\n            }\r\n            \r\n            i=nextChild;\r\n\r\n            if (countGood === children.length) { break }\r\n        }\r\n\r\n        // let total = 0;\r\n        // for (let child of childrenToUpdate) {\r\n        //     total += child.getInputAmount(material)\r\n        // }\r\n        // for (let child of childrenToUpdate) {\r\n        //     child.setInput(material, total / childrenToUpdate.length())\r\n        // }\r\n\r\n\r\n    }\r\n\r\n    wipeOutputToChildren(output, children) {\r\n        if(children.length <= 1){ return }\r\n        console.log('wiped')\r\n        let split = Math.round( output.amount / Math.max( children.length, 1 ) )\r\n        for (let child of children) {\r\n            child.removeInput(output.name, split)\r\n        }\r\n    }\r\n\r\n    splitOutput(output, children) {\r\n        let material = output.name\r\n        let amount = output.amount\r\n        this.wipeOutputToChildren(output, children)\r\n        let countAtMax = 0;\r\n\r\n        //if at full capacity don't count in the split\r\n        for(let child of children) {\r\n            if(child.getInputAmount(material) === child.getInputMax(material)) { countAtMax += 1 }\r\n        }\r\n\r\n        let split = Math.round(amount / (children.length - countAtMax) )\r\n\r\n        for (let child of children) {\r\n            child.addInput(\r\n                material,\r\n                split\r\n            )\r\n            amount -= split\r\n        }\r\n\r\n        if(amount > 0) {\r\n            this.splitOutput(material, amount, children)\r\n        }\r\n    }\r\n\r\n    addChild(_child) { //sets a child node and adds parent\r\n        this.children.push(_child);\r\n    }\r\n    \r\n    removeChild(_child) {\r\n        for (let child of this.getChildren()) {\r\n            if (_child === child) {\r\n                this.children = this.getChildren().filter( (c) => {\r\n                    return (c !== _child)\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    wipeInput() {\r\n        this.input = [];\r\n    }\r\n\r\n    wipeInputOutput() {\r\n        this.input = []; //[{name: a, amount:x}, ...]\r\n        this.output = {};\r\n    }\r\n\r\n    wipeChildrenInput() {\r\n        for(let child of this.children) {\r\n            child.wipeInput()\r\n        }\r\n    }\r\n\r\n    wipeChildren() {\r\n        this.children = [];\r\n    }\r\n\r\n    wipeAll() {\r\n        this.children = [];\r\n        this.maxInput = [];\r\n        this.input = []; //[{name: a, amount:x}, ...]\r\n        this.output = {};\r\n    }\r\n\r\n}"]},"metadata":{},"sourceType":"module"}