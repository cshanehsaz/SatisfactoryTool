{"ast":null,"code":"export default class MachineNode {\n  constructor(_name, _maxInput, _output) {\n    this.name = _name;\n    this.children = [];\n    this.maxInput = _maxInput;\n    this.input = []; //[{name: a, amount:x}, ...]\n\n    this.output = _output; // this.width;\n    // this.height;\n    // this.cost = [];\n  }\n\n  getInput() {\n    return this.input;\n  }\n\n  getOutput() {\n    return this.output;\n  }\n\n  getChildren() {\n    return this.children;\n  }\n\n  getMaxInput() {\n    return this.maxInput;\n  }\n\n  addInput(_name, _amount) {\n    this.input.push({\n      name: _name,\n      amount: _amount\n    });\n  }\n\n  addMaxInput(_name, _amount) {\n    this.maxInput.push({\n      name: _name,\n      amount: _amount\n    });\n  }\n\n  addOutput(_name, _amount) {\n    this.output = {\n      name: _name,\n      amount: _amount\n    };\n  }\n\n  getInputAmount(material) {\n    for (let input of this.getInput()) {\n      if (input.name === material) {\n        return input.amount;\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  getMaxInputAmount(material) {\n    for (let input of this.getMaxInput()) {\n      if (input.name === material) {\n        return input.amount;\n      } else {\n        return 0;\n      }\n    }\n  } // edit this so that it correctly splits the output \n  // and records how much of what is sent to which child\n\n\n  sendOutput() {\n    let children = this.getChildren();\n    let consumption = 0; //total amount of output consumed by children\n\n    let material = this.getOutput().name;\n\n    for (let child of children) {\n      consumption += child.getMaxInputAmount(material);\n    }\n\n    if (consumption >= this.getOutput().amount) {\n      //if consumption > output, split evenly\n      let split = Math.round(this.getOutput().amount / children.length);\n\n      for (let child of children) {\n        child.addInput(material, split);\n      }\n    } else {\n      //split so that each child gets their max input\n      for (let child of children) {\n        child.addInput(material, child.getMaxInputAmount(material));\n      }\n    }\n  }\n\n  addChild(_child) {\n    //sets a child node and adds parent\n    this.children.push(_child);\n  }\n\n  removeChild(_child) {\n    for (let child of this.getChildren()) {\n      if (_child === child) {\n        this.children = this.getChildren().filter(c => {\n          return c !== _child;\n        });\n      }\n    }\n  }\n\n  wipeInputOutput() {\n    this.input = []; //[{name: a, amount:x}, ...]\n\n    this.output = {};\n  }\n\n  wipeChildren() {\n    this.children = [];\n  }\n\n  wipeAll() {\n    this.children = [];\n    this.maxInput = [];\n    this.input = []; //[{name: a, amount:x}, ...]\n\n    this.output = {};\n  }\n\n}","map":{"version":3,"sources":["C:/Users/cshan/Box Sync/website/satisfactory2/src/backend/machineNode.js"],"names":["MachineNode","constructor","_name","_maxInput","_output","name","children","maxInput","input","output","getInput","getOutput","getChildren","getMaxInput","addInput","_amount","push","amount","addMaxInput","addOutput","getInputAmount","material","getMaxInputAmount","sendOutput","consumption","child","split","Math","round","length","addChild","_child","removeChild","filter","c","wipeInputOutput","wipeChildren","wipeAll"],"mappings":"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","sourcesContent":["export default class MachineNode {\r\n    constructor(_name, _maxInput, _output) {\r\n        this.name = _name;\r\n        this.children = [];\r\n        this.maxInput = _maxInput;\r\n        this.input = []; //[{name: a, amount:x}, ...]\r\n        this.output = _output;\r\n        // this.width;\r\n        // this.height;\r\n        // this.cost = [];\r\n    }\r\n\r\n    getInput() {\r\n        return (this.input)\r\n    }\r\n\r\n    getOutput() {\r\n        return (this.output)\r\n    }\r\n\r\n    getChildren() {\r\n        return (this.children)\r\n    }\r\n\r\n    getMaxInput() {\r\n        return (this.maxInput)\r\n    }\r\n\r\n    addInput(_name, _amount) {\r\n        this.input.push({\r\n            name: _name, \r\n            amount: _amount\r\n        })\r\n    }\r\n\r\n    addMaxInput(_name, _amount) {\r\n        this.maxInput.push({\r\n            name: _name, \r\n            amount: _amount\r\n        })\r\n    }\r\n\r\n    addOutput(_name, _amount) {\r\n        this.output = {\r\n            name: _name,\r\n            amount: _amount\r\n        }\r\n    }\r\n\r\n    getInputAmount(material) {\r\n        for (let input of this.getInput()) {\r\n            if(input.name === material) { return (input.amount) }\r\n            else { return (0) }\r\n        }\r\n    }\r\n\r\n    getMaxInputAmount(material) {\r\n        for (let input of this.getMaxInput()) {\r\n            if(input.name === material) { return (input.amount) }\r\n            else { return (0) }\r\n        }\r\n    }\r\n\r\n\r\n    // edit this so that it correctly splits the output \r\n    // and records how much of what is sent to which child\r\n    sendOutput() { \r\n        let children = this.getChildren()\r\n        let consumption = 0; //total amount of output consumed by children\r\n        let material = this.getOutput().name\r\n\r\n        for (let child of children) {\r\n            consumption += child.getMaxInputAmount(material)\r\n        }\r\n\r\n        if (consumption >= this.getOutput().amount) { //if consumption > output, split evenly\r\n            let split = Math.round(this.getOutput().amount / children.length)\r\n            for (let child of children) {\r\n                child.addInput(material, split)\r\n            }\r\n        } \r\n        \r\n        else { //split so that each child gets their max input\r\n            for (let child of children) {\r\n                child.addInput(material, child.getMaxInputAmount(material))\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    addChild(_child) { //sets a child node and adds parent\r\n        this.children.push(_child);\r\n    }\r\n    \r\n    removeChild(_child) {\r\n        for (let child of this.getChildren()) {\r\n            if (_child === child) {\r\n                this.children = this.getChildren().filter( (c) => {\r\n                    return (c !== _child)\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    wipeInputOutput() {\r\n        this.input = []; //[{name: a, amount:x}, ...]\r\n        this.output = {};\r\n    }\r\n\r\n    wipeChildren() {\r\n        this.children = [];\r\n    }\r\n\r\n    wipeAll() {\r\n        this.children = [];\r\n        this.maxInput = [];\r\n        this.input = []; //[{name: a, amount:x}, ...]\r\n        this.output = {};\r\n    }\r\n\r\n}"]},"metadata":{},"sourceType":"module"}